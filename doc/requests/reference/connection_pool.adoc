[#connection_pool]
## connection_pool.hpp

A connection pool represents a collection <<connection>> objects pointing to the same host & port.

[source,cpp]
----

struct connection_pool
{
    /// The type of the executor associated with the object.
    typedef typename Stream::executor_type executor_type;

    /// The type of the underlying connection.
    typedef connection<Stream> connection_type;

    /// Rebinds the socket type to another executor.
    template<typename Executor1>
    struct rebind_executor
    {
        /// The socket type when rebound to the specified executor.
        typedef connection_pool<typename Stream::template rebind_executor<Executor1>::other> other;
    };

    /// Get the executor
    executor_type get_executor() noexcept;

    /// The protocol-type of the lowest layer.
    using protocol_type = typename connection_type::protocol_type;

    /// The endpoint of the lowest lowest layer.
    using endpoint_type = typename connection_type::endpoint_type;

    /// The reolver_type of the lower layer.
    using resolver_type = typename protocol_type::resolver::template rebind_executor<executor_type>::other;


    /// Construct a pool from an executor. 
    template<typename Exec, typename = std::enable_if_t<!detail::has_ssl_v<Stream>, Exec>>
    explicit connection_pool(Exec && exec,
                             std::size_t limit = BOOST_REQUESTS_DEFAULT_POOL_SIZE);

    /// Construct a pool from an executor and sslctx
    template<typename Exec>
    explicit connection_pool(Exec && exec,
                             asio::ssl::context & ctx,
                             std::size_t limit = BOOST_REQUESTS_DEFAULT_POOL_SIZE);

    /// Move constructor
    connection_pool(connection_pool && ) = default;

    /// rebind constructor.
    template<typename Exec>
    connection_pool(connection_pool<Exec> && lhs);
    
    /// Lookup the endpoints for an authority and set the host.
    void lookup(urls::authority_view av);
    void lookup(urls::authority_view sv, system::error_code & ec);
    template<completion_handler_for<void (boost::system::error_code)> CompletionToken
                = asio::default_token_t<executor_type>>
    auto async_lookup(urls::authority_view av, CompletionToken && token = asio::default_token_t<executor_type>());

    /// Get the maximum amount of active connections.
    std::size_t limit() const;
    /// Get the amount of active connections.
    std::size_t active() const;
    /// Get the number of connected connections available
    std::size_t free() const;

    /// Get an open connection that shall be returned later
    connection_type borrow_connection(error_code & ec);
    /// Get an open connection that shall be returned later
    connection_type borrow_connection();

    /// Get an open connection asynchronously that shall be returned later
    template<completion_handler_for<void (system::error_code, connection_type>>
                CompletionToken = default_token_type<CompletionToken>>
    auto async_borrow_connection(CompletionToken && completion_token = default_token<executor_type>);

    /// Get an open connection that  must not be returned later
    connection_type steal_connection(error_code & ec);
    /// Get an open connection that  must not be returned later
    connection_type steal_connection();

    /// Get an open connection asynchronously that must not be returned later
    template<completion_handler_for<void (system::error_code, connection_type>>
                CompletionToken = default_token_type<CompletionToken>>
    auto async_steal_connection(CompletionToken && completion_token = default_token<executor_type>);

    // Check if it's using ssl
    bool uses_ssl() cons;

    // Return a previously borrowed connection
    void return_connection(connection conn);

    // Remove a previously borrowed connection
    void remove_connection(const connection &conn);

    // List all the endpoints used by the pool
    const std::vector<endpoint_type> & endpoints() const;

};

----

### async_lookup
[#connection_pool::async_lookup]

Lookup uses a resolver for the given name and stores the endpoints associated with it.
The pool will internally use all endpoints evenly when creating new connections.